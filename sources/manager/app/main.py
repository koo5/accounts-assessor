#!/usr/bin/env python3


"""
there are three types of workers, three modalities that we'll try to support:

## trusted workers in docker stack
id is generated by docker

## untrusted workers in fly.io machines
id and auth token generated in manager.

## untrusted workers connecting over public internet
These would be set up by user in frontend, id and auth token would be generated for each.

Any metadata like "org" can be looked up from the id.



"""



import logging
import os, sys
import threading
import time

sys.path.append(os.path.normpath(os.path.join(os.path.dirname(__file__), '../../common/libs/misc')))
from tasking import remoulade

from fastapi import FastAPI, Request, File, UploadFile, HTTPException, Form, status, Query, Header
from manager import *

app = FastAPI(
	title="Robust API",
	summary="invoke accounting calculators and other endpoints",
)



@app.post("/worker/{id}/heartbeat")
def heartbeat(id: str):
	"""
	While worker is processing a job, it should take care to call /worker/{id}/heartbeat every minute. - it can also do this the whole time, even when there's no job.
	"""
	get_worker(id, lastseen=time.now())



@app.post("/worker/{id}/messages")
def messages(id: str, job_result=None):
	"""
	Hangs until a message is available. Worker calls this in a loop.
	
	Always at most one message in the queue. The messages are:
		"ping" - worker should respond with "pong"
		a job - worker should start processing the job, and when it's done submit job_result in next call to /worker/{id}/messages
	
	If the manager has been reset while worker is processing a job:
		* this job_result will be ignored, worker will go on to the next job.
		* the remoulade job will eventually get marked as failed.
	
	IF the worker has been reset while processing a job:
		manager detects this because it expects a job_result, but gets none. The remoulade job will be made to return with failure.
	
	"""
	worker = get_worker(id, lastseen=time.now())
	if job_result:
		events.push(dict(type='job_result', worker=worker, result=job_result))
	elif worker.job:
		# this worker has no result to submit, but it still hit /messages. This means that is has been reset, and it's trying to get a new job.
		events.push(dict(type='worker_reset', worker=worker))

	return worker.toworker.pop()



# not sure how to compose this cleanly. We dont want fronted to import the whole queueing shebang.
import manager_actors
manager_actors.do_job = do_job



def remoulade_thread():
	"""
	this is a copy of remoulade.__main__.start_worker that works inside a thread.
	Spawn a remoulade worker and periodically check if it's still running.
	"""
	logger = logging.getLogger('remoulade')

	broker = remoulade.get_broker()
	broker.emit_after("process_boot")

	worker = remoulade.Worker(broker, queues=['default'], worker_threads=1, prefetch_multiplier=1)
	worker.start()

	running = True
	while running:
		if worker.consumer_stopped:
			running = False
		if worker.worker_stopped:
			running = False
			logger.info("Worker thread is not running anymore, stopping Worker.")
		else:
			time.sleep(1)

	worker.stop(5 * 1000)
	broker.emit_before("process_stop")
	broker.close()



print(threading.Thread(target=remoulade_thread, daemon=True).start())
print(threading.Thread(target=synchronization_thread, daemon=True).start())


