<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>


  <script type="importmap">
    {
      "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
      }
    }
  </script>
  

	<script type="text/javascript" src="jquery-3.4.0.js"></script>
	<script src="lodash.js"></script>
	

	<link id="stylesheet" rel="stylesheet" href="styles.css">
	
</head>
<body>


<div id="app">
	<node_outer :node="node"></node_outer>
</div>


<script type="module">
	'use strict';
	
	import { createApp, defineComponent, h } from 'vue';

 	const searchParams = new URLSearchParams(window.location.search);


  document.addEventListener('DOMContentLoaded', (event) => {
    const link = document.getElementById('stylesheet');
    link.href = link.href + '?v=' + new Date().getTime();
  });


	function Node(n3)
	{
	  /* n3 is the n3 representation of the node. It is the unique identifier. */
		this.n3 = n3;
		/* term contains data for presenting the identifier or literal as a string. */
		this.term={short: n3};
		/* UI state. loading, expanded, etc. */
		this.state={};
		/* per-source information and state */
		this.sources=[{msg: "loading " + n3 + "..."}];
		/* properties of the node */
		this.props=[];
		/* external links for browsing the node */
		this.tools=[];
	}
  

  

  const app = createApp({
  
    data() {
      return {
        node: new Node(searchParams.get('node') || '<https://rdf.lodgeit.net.au/v1/request#Result>')
        
      }
    },
    
    mounted() {
      load_node_data_all(this.node, (e) => {console.log("error: " + e);});
    }
    
    
  });

  app.component('node_outer', {
    props: ['node'],
    template: `
      <span>
        <b><term :term="node.term"></term></b>
        properties:
        <node :node="node"/>
      </span>
    `
  });

  
  app.component('term', {
    inject: ['focused_graph'],
		props: ['term'],
		template: `<span>
            <span v-if="term?.reverse">is </span>
            <span v-else-if="term?.forward">has </span>
            <span  v-if="term === undefined">-</span>
            <span  v-else-if="term.fake !== undefined">{{ term.fake }}</span>
            <template v-else-if="typeof term == 'string'">
              s: <span class="identifier">{{ term }}</span>
            </template>
            <template v-else-if="term.literal_str === ''">
              <small>
                <a :href="term.href + '&focused-graph=' + this.focused_graph">(empty string)</a>
              </small>
            </template>
            <template v-else-if="term.literal_str !== undefined">
              <span>
                s: <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.literal_str }}</a>
              </span>
            </template>
            <template v-else-if="term.label">
              <span class="identifier" >
                l: <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.label.l }}</a>
              </span>
            </template>
            <template v-else-if="term.short">
            (short: )
              <span class="identifier">
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.short }}</a>
              </span>
            </template>
            <template v-else-if="term.uri">
            (uri: )
              <span class="identifier">
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.uri }}</a>
              </span>
            </template>
            
            <template v-else>
              ???
            </template>
            <span v-if="term?.reverse">
              of
            </span>
          </span>
		`,
  });


  app.component('quad', {
      inject: ['focused_graph'],
      props: ['quad'],
      template: `
		
        <td :class="{ 'general' : prop.category?.fake == 'general' }">
            <term :term="quad.p.term"" />
        </td>
        <td>                           
            <term_expandable :node="quad.o" :interesting="quad.g.uri == this.focused_graph && quad.category?.fake == 'general'"/>
        </td>
        <td :class="{ 'focusedGraph' : quad.g.uri == this.focused_graph, graph : true }">
            <term_expandable :node="quad.g"/>
        </td>

  `
  });

  app.component('node', {
    inject: ['focused_graph'],
		props: ['node'],
    template: `
      <span :class="{ 'focusedGraph' : false }">
        <span v-for="source in node.sources">
            <div v-if="source.msg!='loaded'">
              <small>({{ source.msg }})</small>
            </div>
        </span>

        <span v-if="node.list_item">
          * <node :node="node.list_item" />
          <node v-if="node.list_tail" :node="node.list_tail" />
          <span v-else>
            <small>(list end)</small>
          </span>
        </span>

        <table v-else-if="node.props">
              <thead>
                    <tr>
                      <th>property</th>
                      <th>value</th>
                      <th>source</th>
                    </tr>
                  </thead>

              <tbody>             
                    <tr v-for="quad in node.props" :key="quad.id">
                      <quad :quad="quad"/>
                    </tr>
            </tbody>
        </table>
          
        <small v-if="node.tools">
            browse {{ node.term.n3 }} also in:
            <ul>
            
                <li  v-for="tool in node.tools">
                    <a v-bind:href="tool.url">{{ tool.label }}</a>
                </li>   

            </ul>
        </small>
          
      </span>
    `
  });
  
    
  app.component('term_expandable', {
     props: ['node', 'interesting'],
     template: `
<div class="expandable" :class="{ 'expanded' : node.state.expanded }"  >
    <div :class="{ 'focusedGraphAndGeneral' : interesting }">
        <button v-if="(node.term.literal_str !== undefined) || node.term.uri" @click="toggle_expanded" >{{ node.state.expanded ? '-' : ' + ' }}</button><term :node="node"/>
    </div>
    
    <Transition>
       <node v-if="node.state.expanded" :node="node" />
    </Transition>
</div>          
    `,
     methods: {
         toggle_expanded: function () {
             let expanded = !this.node.state.expanded;
             console.log("expanded:" + expanded);
             if (expanded && !this.node.state.loading) 
             {
                 this.node.state.loading = true;
                 load_node_data_all(this.node, (e) => {this.node.state.loading = false;}).then(
                     () => {
                         console.log("loaded.");
                         this.node.state.loading = false;
                     }
                 ).catch(
                     (error) => {
                         console.log("error: " + error);
                     }
                 );
    		     }
             this.node.state.expanded = expanded;
         }
     }
 });


  
  
	function load_node_data_all(node, fail_callback)
	{
		return Promise.all([
			load_node_data1(node.n3).then(
						results => {
							assign_node_data1(node, results);
							node.sources[0].msg = 'loaded';
						}
						).catch(
							(error) => {
							  node.sources[0].msg = "error: " + error;
							  fail_callback && fail_callback(error)
              }
            )
		]);
	};

	function load_node_data1(n3) {
		return new Promise(
			function(resolve, reject)
			{
				var url = '/api/rdftab?node='+encodeURIComponent(n3);
				$.ajax({
					dataType: "json",
					mimeType: "application/json",
					url: url,
					success: function(data){
					    resolve(data);
					},
					error: function() {
						reject("loading "+url+" failed");
					}
				});
			}
		);
	}

	function assign_node_data1(node, result) {
		console.log("assign_node_data1:\nnode:\n" + JSON.stringify(node, null, 2) + "\nresult:\n" + JSON.stringify(result, null, 2));
		result.props.forEach(function (x) {
			node.props.push({p: new Node(x.p.n3), o: new Node(x.o.n3), g: new Node(x.g.n3), category: x.category, id: x.id});
		}
		result.tools.forEach(function (x) {
			node.tools.push(x);
		}
		load_list_item(node);

	}
  
	function load_list_item(node) {
		console.log("load_list_item:"+JSON.stringify(node, null, 2));
		let first = undefined;
		let rest = undefined;

		if (node.props) {
			node.props.forEach(function (prop) {
				if (prop.p.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#first>') {
					first = prop.o;
				} else if (prop.p.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#rest>') {
					rest = prop.o;
				}
			});
		}

		console.log("first:");console.log(first);
		console.log("rest:");console.log(rest);
		
		if (first) {
			node.list_item = new Node(first.n3);
      load_node_data_all(node.list_item);
		}
		if (rest && (rest.n3 != '<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>')) {
			node.list_tail = new Node(rest.n3);
		  load_node_data_all(node.list_tail);
		}
	}


    
  app.provide('focused_graph', searchParams.get('focused-graph'));


  app.mount('#app');



</script>

