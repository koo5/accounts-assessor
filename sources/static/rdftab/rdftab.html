<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>


  <script type="importmap">
    {
      "imports": {
        "vue": "./vue.esm-browser.js"
      }
    }
  </script>
  

	<script type="text/javascript" src="jquery-3.4.0.js"></script>
	<script src="lodash.js"></script>
	

	<link id="stylesheet" rel="stylesheet" href="styles.css">
	
</head>
<body>


<div id="app">
	<Node_outer :node="node"></Node_outer>
</div>


<script type="module">
	'use strict';
	
	import { createApp } from 'vue';
  
 	const searchParams = new URLSearchParams(window.location.search);


  document.addEventListener('DOMContentLoaded', (event) => {
    const link = document.getElementById('stylesheet');
    link.href = link.href + '?v=' + new Date().getTime();
  });


	function Node(n3, term)
	{
	  /* n3 is the n3 representation of the node. It is the unique identifier. */
		this.n3 = n3;
		/* term contains data for presenting the identifier or literal as a string. */
		if (term) {
			this.term=term;
		} else {
			this.term = {short: n3};
		}
		/* loading state */
		this.state={};
		/* per-source information and state */
		this.sources=[{msg: "loading..." + n3 + "..."}];
		/* properties of the node */
		this.props=[];
		/* external links for browsing the node */
		this.tools=[];
	}
  

  

  const app = createApp({
  
    data() {
      return {
        node: new Node(searchParams.get('node') || '<https://rdf.lodgeit.net.au/v1/request#Result>')
        
      }
    },
    
    mounted() {
      load_node_data_all(this.node, (e) => {console.log("error: " + e);});
    }
    
    
  });

  app.component('Node_outer', {
    props: ['node'],
    template: `
      <span>
        <b><Term :term="node.term" /></b>
        properties:
        <Node :node="node"/>
      </span>
    `
  });

  
  app.component('Term', {
    inject: ['focused_graph'],
		props: ['term', 'interesting', 'node'],
		mounted() {
      if (this.interesting && this.node) {
        load_node_data_all(this.node);
      }
    },
		template: `<span>
x{{ this.interesting }}x{{ true && this.node }}x
            <span v-if="term?.reverse">is </span>
            <span v-else-if="term?.forward">has </span>
            <span  v-if="term === undefined">(undefined)-</span>
            <span  v-else-if="term.fake !== undefined">{{ term.fake }}</span>
            <template v-else-if="typeof term == 'string'">
              <span class="term_string">{{ term }}</span>
            </template>
            <template v-else-if="term.literal_str === ''">
              <small>
                <a :href="term.href + '&focused-graph=' + this.focused_graph">(empty string)</a>
              </small>
            </template>
            <template v-else-if="term.literal_str !== undefined">
              <span class="term_literal">
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.literal_str }}</a>
              </span>
            </template>
            <template v-else-if="term.label">
              <span class="identifier" >
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.label.l }}</a>
              </span>
            </template>
            <template v-else-if="term.short">
              <span class="term_short">
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.short }}</a>
              </span>
            </template>
            <template v-else-if="term.uri">
              <span class="term_uri">
                <a :href="term.href + '&focused-graph=' + this.focused_graph">{{ term.uri }}</a>
              </span>
            </template>
            
            <template v-else>
              ??? {{ JSON.stringify(term) }} ???
            </template>
            <span v-if="term?.reverse">
              of
            </span>
            <span v-if="node?.rdf_value">
             -> <Term_expandable :node="node.rdf_value" />
            </span>
          </span>
		`,
  });


  app.component('Quad', {
      inject: ['focused_graph'],
      props: ['quad', 'parent'],
      computed: {
        interesting() {
          return this.quad.g.term.uri == this.focused_graph && this.quad.category?.fake == 'general';
        }
      },
      template: `
		
        <td :class="{ 'general' : quad.category?.fake == 'general' }">
            <Term :term="quad.p.term" />
        </td>
        <td :class="{ 'interesting' : interesting }">
        
<!--        t{{ this.focused_graph }}t-->
<!--        tt{{ quad.g.term.uri }}tt-->
<!--        f{{ quad.g.uri == this.focused_graph }}f-->
<!--        g{{ quad.category?.fake == 'general' }}g                           -->
            <Term_expandable :parent="parent" :leadin="quad" :node="quad.o" :interesting="interesting"/>
        </td>
        <td :class="{ 'focusedGraph' : quad.g.uri == this.focused_graph, graph : true }">
            <Term_expandable :node="quad.g"/>
        </td>

  `
  });

  app.component('Node', {
    inject: ['focused_graph'],
		props: ['node', 'is_list_tail', 'leadin', 'parent'],
		computed: {
		
		  /* the "leadin" quad is the quad that led from parent node to this node. 
		  we find the id of the own quad that corresponds to the leadin quad, to hide it from the list of properties.
		  This is different from the QuadLad approach, where each quad would be displayed only once. Here we just hide an obvious duplicity between two spatially close elements */
        
  		leadin_id() {
        if (!this.leadin) return 'no leadin';
        if (!this.parent) return 'no parent';
        for (let quad of this.node.props)
        {
          // console.log('leadin_id: '+JSON.stringify(quad.p.n3, null, 2) + ' ' + JSON.stringify(this.leadin.p.n3, null, 2));
          if (
            this.leadin.p.n3 == quad.p.n3 /*&& 
            this.leadin.p.term.reverse == !quad.p.term.reverse && 
            this.parent.n3 == quad.o.n3 && 
            this.leadin.g.n3 == quad.g.n3*/)
          {
            return quad.id;
          }
        }
        return 'no match'+JSON.stringify(this.node.props.length, null, 2);
      }
    },
    template: `
      <div :class="{ 'focusedGraph' : false }">
        <span v-for="source in node.sources">
            <div v-if="source.msg!='loaded'">
              <small>({{ source.msg }})</small>
            </div>
        </span>
<!--<pre>-->
<!--%{{ JSON.stringify(this.leadin?.p.n3, null, 2) }}%-->
<!--%{{ JSON.stringify(this.node.props, null, 2) }}%-->
<!--</pre>-->

        <span v-if="node.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>'">
          <small>(list with no items)</small>
        </span>

        <span v-else>
          <span v-if="node.list_item">

            <span v-if="!is_list_tail">this node is a list with items:<br>
            <ol>
              <li>
                <Term_expandable :node="node.list_item" :interesting="true" />
              </li>
              <Node v-if="node.list_tail" :node="node.list_tail" :is_list_tail="true"/>
              <span v-else>
                <small>(end of list)</small>
              </span>                        
            </ol>
            </span>
            
            <span v-else>
              <li>
                <Term_expandable :node="node.list_item" :interesting="true" />
              </li>
              <Node v-if="node.list_tail" :node="node.list_tail" :is_list_tail="true"/>
              <span v-else>
                <small>(end of list)</small>
              </span>            
            </span>
          
          </span>
          
          <table v-if="!node.list_item && node.props">
                <thead>
                      <tr>
                        <th>property</th>
                        <th>value</th>
                        <th>source</th>
                      </tr>
                    </thead>
  
                <tbody>             
                    <template v-for="quad in node.props" :key="quad.id">
                      <tr v-if="quad.id != leadin_id">
<!--                      {{ quad.id }}-->
<!--                          |{{ JSON.stringify( this.leadin_id, null, 2) }}|-->
<!--                        quad{{ JSON.stringify(quad, null, 2) }}-->
                        <quad :quad="quad" :parent="node" />
                      </tr>
                    </template>
                </tbody>
          </table>
            
          <small v-if="node.tools && !node.list_item">
              browse {{ node.n3 }} also in:
              <ul>
              
                  <li v-for="tool in node.tools">
                      <a v-bind:href="tool.url">{{ tool.label }}</a>
                  </li>   
  
              </ul>
          </small>
        
        </span>
        
      </div>
    `
  });
  
    
  app.component('Term_expandable', {
     props: ['node', 'interesting', 'leadin', 'parent'],
     data() {
       return {
         expanded: false
       }
     }, 
     template: `
<span class="expandable" :class="{ 'expanded' : node.state.expanded }"  >
<!--i{{ interesting }}i-->
    <span :class="{ 'interesting' : interesting }">
        
<!--        bbb{{ JSON.stringify(node, null, 2) }}zzz-->
        <button v-if="(node.term.literal_str !== undefined) || node.term.uri" @click="toggle_expanded" >{{ expanded ? '-' : ' + ' }}</button><Term :term="node.term" :node="node" :interesting="interesting" />
    </span>
    
    <Transition>
       <Node v-if="expanded" :node="node" :leadin="leadin" :parent="parent"/>
    </Transition>
</span>          
    `,
     methods: {
         toggle_expanded: function () {
             this.expanded = !this.expanded;
             console.log("expanded:" + this.expanded);
             if (this.expanded) 
                 load_node_data_all(this.node);
         }
     }
 });


  
  
	function load_node_data_all(node, fail_callback)
	{
    
    if (node.state.loaded || node.state.loading) return Promise.all([]);
    node.state.loading = true;
      
		return Promise.all([
			load_node_data1(node.n3).then(
						results => {
						  
						  node.state.loaded = true;
						  node.state.loading = false;
						  
							assign_node_data1(node, results);
							node.sources[0].msg = 'loaded';
						}
						).catch(
							(error) => {
							  node.sources[0].msg = "error: " + error;
							  fail_callback && fail_callback(error)
							  node.state.loading = false;
              }
            )
		]);
	};

	function load_node_data1(n3) {
		return new Promise(
			function(resolve, reject)
			{
				var url = '/api/rdftab?node='+encodeURIComponent(n3);
				$.ajax({
					dataType: "json",
					mimeType: "application/json",
					url: url,
					success: function(data){
					    resolve(data);
					},
					error: function() {
						reject("loading "+url+" failed");
					}
				});
			}
		);
	}

	function assign_node_data1(node, result) {
	
	  /*
	  result is the object coming from the backend,
	  {
	    "repo":
	    "props":
	    "tools":
	    "namespaces":
	    "term": // this is basic data for presenting the node in a short form, like the n3 string, literal value, uri, etc.
	  }
	  */

		console.log("assign_node_data1:\nnode:\n" + JSON.stringify(node, null, 2) + "\nresult:\n" + JSON.stringify(result, null, 2));
		
		node.namespaces = result.namespaces;
		node.repo = result.repo;
		node.user = result.user;
		
		for(let key in result.term) {
      node.term[key] = result.term[key];
    };

		result.props.forEach(function (x) {
			node.props.push(
					{
						p: new Node(x.p.n3, x.p),
						o: new Node(x.o.n3, x.o),
						g: new Node(x.g.n3, x.g),
						category: x.category,
						id: x.id
					}
			);
		});
		result.tools.forEach(function (x) {
			node.tools.push(x);
		});
    
    load_list_item(node);
	}
  
	function load_list_item(node) {
		console.log("load_list_item:"+JSON.stringify(node, null, 2));
		let first = undefined;
		let rest = undefined;

    for (let prop of node.props)
    {
      if (prop.p.term.forward) {
          if (prop.p.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#first>') {
              // console.log("first:");console.log(first);
              //console.log(JSON.stringify(prop.p, null, 2));
              node.list_item = prop.o;
              setTimeout(() => {
                load_node_data_all(node.list_item);
              }, 10);
          } else if (prop.p.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#rest>' && prop.o.n3 != '<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>') {
              // console.log("rest:");console.log(rest);
              //console.log(JSON.stringify(prop.p, null, 2));
              node.list_tail = prop.o;
              setTimeout(() => {
                load_node_data_all(node.list_tail);
              }, 10);
          }
          else if (prop.p.n3 == '<http://www.w3.org/1999/02/22-rdf-syntax-ns#value>') {
              node.rdf_value = prop.o;
          }
      }
    }
	}

    
  app.provide('focused_graph', searchParams.get('focused-graph'));
  app.mount('#app');

</script>

