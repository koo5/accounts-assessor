/*
the concept of a role of an account: If a trading account Financial_Investments already contains
an account with id Financial_Investments_realized, either it has to have a role Financial_Investments/realized,
or is not recognized as such, and a new one with proper role is proposed. This allows us to abstract away from ids,
because Financial_Investments_realized might already be an id of another user account.
*/


find_or_add_required_accounts(S_Transactions) :-
	ensure_bank_gl_accounts_exist,
	ensure_livestock_accounts_exist,
	traded_units(S_Transactions, Traded_Units),
	ensure_financial_investments_accounts_exist(Traded_Units),
	ensure_investment_income_accounts_exist(Traded_Units).




roles_tree([(Child_Roles, Detail_Level)|Roles_Tail],Parent_Id) :-
	findall(
		(Parent_Id/Child_Role),
		member(Child_Role, Child_Roles),
		Roles
	),
	maplist(ensure_account_exists(Accounts_In, Parent_Id, Detail_Level), Roles, System_Accounts),
	flatten([Accounts_In, System_Accounts], Accounts_Mid),
	findall(
		System_Account_Id,
		(
			member(System_Account, System_Accounts),
			account_id(System_Account, System_Account_Id)
		),
		System_Account_Ids
	),			
	maplist(
		roles_tree(
			Accounts_Mid, 
			Roles_Tail
		),
		System_Account_Ids, 
		Grandchild_Accounts
	),
	flatten([Accounts_Mid, Grandchild_Accounts], Accounts_Out).

roles_tree(_, [], _, []).




ensure_account_exists(Suggested_parent, Suggested_id, Detail_level, Role, Account) :-
	(	account_by_role(Role, Account)
	->	true
	;	(
			(	nonvar(Suggested_id)
			->	true
			;	(
					Role = (_/Child_Role_Raw),
					replace_nonalphanum_chars_with_underscore(Child_Role_Raw, Child_Role_Safe),
					capitalize_atom(Child_Role_Safe, Child_Role_Capitalized),
					atomic_list_concat([Parent, '', Child_Role_Capitalized], Suggested_id)
				)
			),
			account_free_id(Suggested_id, Free_Id),
			make_account(Free_Id, Suggested_parent, Detail_level, Role, Uri),
			doc_add(Uri, l:autogenerated, true, accounts)
		)
	).

/*
	find an unused account id.
	if an account with id Id is found, append _2 and try again,
	otherwise bind Free_Id to Id.
*/
account_free_id(Id, Free_Id) :-
		account_exists(Id)
	->	(
			atomic_list_concat([Id, '_2'], Next_Id),
			account_free_id(Next_Id, Free_Id)
		)
	;	Free_Id = Id.

